1) Il  faut faire pour écrire un chiffre négatif, regarder sur internet complément à deux, ainsi pour toute les valeurs immédiates le dernier bit est un bit signé.
Check


2) Commencer à construire la mémoire ou les registres

Pour la mémmoire :

    - elle fait 4 Go

    - il faut écrire les instructions dans la mémoire avec le type BIG ENDIAN (chaque instruction est codés sur 4 octets).


    - il faut créer une structure de type liste chainée ou dans chaque éléments de la liste il y a une structure contenant l'adresse de la mémoire et sa valeurs (l'adresse va de 0x00000000 à 0xFFFFFFFF donc l'adresse est aussi coder sur 32 bits)

    - il faut faire une fonction qui pourras écrire dans la mémoire en lui donnant les arguments (adresse et valeur) si on écrit dans la mémoire alors on crée un nouveau morceau dans notre structure de liste

    - et une fonction qui lit les donnée dans la mémoire


    //int binaire3[32] = {0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0}; 	//	ADD  R01 + R02 --> R04
	//int binaire3[32] = {0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0};		//	ADDI 17412 + R02 --> R04
	//int binaire3[32] = {0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0}; 	//	SUB  R01 - R02 --> R04
	//int binaire3[32] = {0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0}; 	//	AND  R01 & R02 --> R04
	//int binaire3[32] = {1,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0};   	//	OR   R01 | R02 --> R04
	//int binaire3[32] = {0,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 	//	SLL  R02 << 28 --> R04
	//int binaire3[32] = {0,1,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0};		//	SLT  R02 < R01 ? --> R04
	//int binaire3[32] = {0,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0};		//	XOR  R01 XOR R02 --> R04
	//int binaire3[32] = {0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 	//	SRL  R02 >> 2 --> R04
	//int binaire3[32] = {0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0}; 	//	ROTR R02 >> 2 --> R04
	//int binaire3[32] = {0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0};		//	MULT R02 * 30 --> R26/27
	//int binaire3[32] = {0,1,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};		//	MFLO R8 <-- R26
	//int binaire3[32] = {0,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};	    //	MFHI R12 <-- R27
	//int binaire3[32] = {0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,1,1};		//	LW   R4 <-- 2(R2)
	//int binaire3[32] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,1,0,1,1};		//	SW 	 R2 --> 0(R4)			
	//int binaire3[32] = {0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1};		//  LUI R2 = 12 || 0^16
	//int binaire3[32] = {0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1};		//  JAL 12
	//int binaire3[32] = {0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0};		//  JR R2
	//int binaire3[32] = {0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0};		//  J 12
	//int binaire3[32] = {0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,0,1};		//  BNE R4 != R2 ? --> PC  + 12
	//int binaire3[32] = {0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,1};		//	BGTZ R2 > 0 ? --> PC  + 12
	//int binaire3[32] = {0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,0};		//  BLEZ R2 <= 0 ? --> PC  + 12
	//int binaire3[32] = {0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,0};		//	BEQ R8 = R2 ? --> PC  + 12
	//int binaire3[32] = {0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0};		//	DIV R2/R4 --> R26/27


	// char charInstruction;
	// char instruction[64];


	// int PC = 0;
	// int addressInstruction = 0;
	// int numberOfInsructionWritten = 0;
	// int cmptChar = 0;
	// int isOneSpaceChar = 0;
	// int insNotBegin = 1;
	// int numberOfRow = 1;

	// while(!feof(inputFile)) {
	// 	fscanf(inputFile, "%c", &charInstruction);
	
	// 	if(charInstruction == '\n' || feof(inputFile)) {
	// 		instruction[cmptChar] = '\0';
	// 		cmptChar = 0;

	// 		if(!isStringFullOfSpaces(instruction) && !isBeginWithCommentCharBeforeAnyCharOtherThanSpace(instruction)) {
	// 			int binaireInstruction[32] = {0};
	// 			int hexadecimalInstruction[8] = {0};
	// 			char operation[10];
	// 			int values[3];

	// 			instructionValue(instruction, values, operation);
	// 			// printf("%s\n", operation);
	// 			// printf("%d\n", values[0]);
	// 			// printf("%d\n", values[1]);
	// 			// printf("%d\n", values[2]);

	// 			if(!createBinaryInstruction(operation, values, binaireInstruction)) {
	// 				convertBinaireIntoHex(binaireInstruction, hexadecimalInstruction);
	// 				// int i;
	// 				// for(i=31;i>=0;i--)
	// 				// {
	// 				// 	printf("%d",binaireInstruction[i]);
	// 				// }
	// 				// printf("\n");

	// 				writeFourOctetsInMemory(binaireInstruction, addressInstruction, 1, &RAM);
	// 				numberOfInsructionWritten++;
	// 				addressInstruction += 4;

	// 				displayHexadecimal(hexadecimalInstruction);
	// 				printf(" : {%s}\n", instruction);

	// 				/* writing exa in output file */
	// 				for(int i=0; i<8; i++) {
	// 					fprintf(outputFile, "%x", hexadecimalInstruction[i]);
	// 				}
	// 				fputc('\n', outputFile);
	// 			}
	// 			else {
	// 				printf("Erreur de syntaxe ligne : %d\n", numberOfRow);
	// 				break;
	// 			}
	// 		}
	// 		numberOfRow++;
	// 	}
	// 	else if(charInstruction == ' ' && (isOneSpaceChar || insNotBegin)){
	// 		1 == 1;
	// 	}
	// 	else if(cmptChar <= 62){
	// 		instruction[cmptChar++] = charInstruction;
	// 		insNotBegin = 0;
	// 	}

	// 	if(charInstruction == ' ') {
	// 		isOneSpaceChar = 1;
	// 	}
	// 	else {isOneSpaceChar = 0;}

	// }
	
	// int i;
	// int tempPC = 0;
	// int moreInstruction = 1;

	// while(moreInstruction)
	// {
	// 	i = 0; tempPC = 0;

	// 	for(i=31;i>=0;i--)
	// 	{
	// 		tempPC += (unsigned long long int) (pow(2, i) * tableRegister[32].registre[i]);
	// 	}
	// 	PC = tempPC;

	// 	if(PC < 4*numberOfInsructionWritten) {
	// 		readAndDecodeInstruction(PC, tableRegister, &RAM);
	// 		printf("\n");
	// 	}
	// 	else {
	// 		moreInstruction = 0;
	// 	}
	// }


int isStringFullOfSpaces(const char *string)
{
    int i = 0;
    int isFullOfSpaces = 1;

    while(string[i] != '\0' && isFullOfSpaces) {
        if(string[i++] != ' ') {
            isFullOfSpaces = 0;
        }
    }
    return isFullOfSpaces;
}

int isBeginWithCommentCharBeforeAnyCharOtherThanSpace(char *string)
{   
    int i = 0;
    int isCommentLine = 0;

    while(string[i] != '\0' && (string[i] == ' ' || string[i] == '#')) {
        if(string[i++] == '#') {
            isCommentLine = 1;
        }
    }
    return isCommentLine;
}

int instructionValue(const char *instruction, int *tabValues, char *operation)
{
    int i = 0; int j; int indiceValue = 0; int lengthValue = 1; int k; ; int negativeValue; int numberOfValues = 3; /*Pour limiter l'écriture de seulement 3 valeurs max dans le tableau de value */
    int getInstructionBool = 0;
    int indiceStartInstruction = 0; int indiceEndInstruction = 0;

    while(instruction[i] != '\0' && instruction[i] != '#' && numberOfValues != 0) {
        if((instruction[i] == ' ' || instruction[i] == ',' || instruction[i] == '(') && indiceEndInstruction != 0) {
            getInstructionBool = 1;
            operation[indiceEndInstruction] = '\0';
            /* To remove the '$' from the number */
            if(instruction[i+1] == ' ') {
                if(instruction[i+2] == '$') {
                    j = i+3;
                }
                else {
                    j = i+2;
                }
            }
            else {
                if(instruction[i+1] == '$') {
                    j = i+2;
                }
                else {
                    j = i+1;
                }
            }
            
            int temp = j;

            /* If there is a negative value I just go 1 char after and remember it */
            if(instruction[temp] == '-') {
                temp++;   /*When we count the length of the number */
                j++;     /* When we will convert the char into int */
                negativeValue = 1;
            }
            else {
                negativeValue = 0;
            }
            /* Get the length if the value */
            while(instruction[temp+1] != ',' && instruction[temp+1] != '(' && instruction[temp+1] != ')' && instruction[temp+1] != ' ' && instruction[temp+1] != '#' && instruction[temp+1] != '\0') {
                lengthValue += 1;
                temp++;
            }
            /*We can go throw all the part of the instruction */
            if(instruction[temp+1] == ' ' && instruction[temp+2] == ',') {
                i = temp + 1;
            }
            else {
                i = temp;
            }

            /* Add the value to the list */
            tabValues[indiceValue] = 0;
            for(k=lengthValue; k>0; k--) {
                tabValues[indiceValue] += (int) (instruction[j]-48) * pow(10, k-1);
                j++;
            }
            if(negativeValue) {
                tabValues[indiceValue] *= -1;
            }
            numberOfValues--;
            indiceValue++;
            lengthValue = 1;
        }
        /* Get the operation of the instruction */
        if(!getInstructionBool && instruction[i] != ' ') {
            operation[indiceStartInstruction++] = instruction[i];
            indiceEndInstruction = i+1;
        }
        /* For NOP operation */
        if(instruction[i+1] == '\0') {
            operation[indiceEndInstruction] = '\0';
        }
        i++;
    }
    return 0;
}